module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  // CONNECTS WHATEVER SOURCES WE HAVE TO EXTERNAL INPUT OUTPUTS
  sig rst;                  // reset signal
  const Y_VALUES = {1000000000000000,
                    1100000000000000, 
                    1110000000000000, 
                    1111000000000000, 
                    1111100000000000}; 
  // Y_VALUES[0] is 5b1, 11b0
  // Y_VALUES[4] is b1, 15b0
  
  dff firstrow[16](#INIT(Y_VALUES[0]),.clk(clk)); //init needs to be a constant value
  dff secondrow[16](#INIT(Y_VALUES[1]),.clk(clk));
  dff thirdrow[16](#INIT(Y_VALUES[2]),.clk(clk));
  //dff fourthrow[16](#INIT(Y_VALUES[3]),.clk(clk));
  

  //counter slowclock4th(#SIZE(1),#DIV(22),.clk(clk), .rst(rst));
  
  shifter shiftingleft;
  shifter shiftingright;
  sig shiftleftcount;
  sig shiftrightcount;

   


    .clk(clk) {
      
    
      fsm game_fsm={STARTROW1,
      STARTROW2,
      STARTROW3,
      STARTROW4,
      STARTROW5};
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    .rst(rst){
      counter slowclock1st(#SIZE(1),#DIV(28));
      counter slowclock2nd(#SIZE(1),#DIV(26));
      counter slowclock3rd(#SIZE(1),#DIV(24));

    }
      reset_conditioner reset_cond;
      button_conditioner button_conditioner[5];
      edge_detector buttonpress(#RISE(1), #FALL(0));
      edge_detector edgerow1 (#RISE(1), #FALL(0));
      edge_detector edgerow2 (#RISE(1), #FALL(0));
      edge_detector edgerow3 (#RISE(1), #FALL(0));
      //edge_detector edgerow4 (#RISE(1), #FALL(0));
    }  

    
  always {
    reset_cond.in = ~rst_n;   // input raw inverted reset signal
    rst = reset_cond.out;     // conditioned reset
    io_led = 3x{{h00}};       // turn all LED off at first
    usb_tx = usb_rx;          // loop serial port
    io_seg = 8hff; // connect segments to the driver
    io_sel = 4hf; // connect digit select to the driver

    
    led = c{3b0, io_button};  // connect buttons to LEDs
      
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off

    usb_tx = usb_rx;        // echo the serial data
      
    button_conditioner.in = io_button[4:0];
    buttonpress.in = button_conditioner.out[4];
    
    edgerow1.in = slowclock1st.value;
    edgerow2.in = slowclock2nd.value;
    edgerow3.in = slowclock3rd.value;
    //edgerow4.in = slowclock4th.value;

    shiftrightcount = 0;
    shiftingright.a = 0;
    shiftingright.b = b1;
    shiftingright.alufn_signal = b01; // shifts right first
      
    shiftleftcount = 0;
    shiftingleft.a = 0;
    shiftingleft.b = 0;
    shiftingleft.alufn_signal = b00; // shifts left after, then cycle repeats
    
    if (rst){
        game_fsm.d = game_fsm.STARTROW1;
    }
    else{
    
    case(game_fsm.q){
    
      game_fsm.STARTROW1:
      
      edgerow1.in = slowclock1st.value;
      shiftrightcount = 0;
      shiftingright.a = firstrow.q;
      shiftingright.b = b1;
      shiftingright.alufn_signal = b01; // shifts right first
      
      shiftleftcount = 0;
      shiftingleft.a = firstrow.q;
      shiftingleft.b = b1;
      shiftingleft.alufn_signal = b00; // shifts left after, then cycle repeats
      
      if (edgerow1.out == 1){
          shiftrightcount = shiftrightcount + 1;
          shiftleftcount = shiftleftcount + 1;
          
          if (shiftrightcount <= 11 | shiftrightcount >= 0){ //11 to be replaced with math involving 16 - size of block
            firstrow.d = shiftingright.shift;
            }
          
          if (shiftrightcount == 11){ //11 to be replaced with math involving 16 - size of block
            shiftrightcount = shiftrightcount - 22;
          }
            
          if (shiftleftcount >= 11 | shiftleftcount < 22 ){ //shiftleftcount could be > 11, not >=11. shiftrightcount < 22 to be replaced with  (16 - size of block) x 2
            firstrow.d = shiftingleft.shift;
          }
            
          if (shiftrightcount == 22){ //shiftrightcount < 22 to be replaced with  (16 - size of block) x 2
            shiftleftcount = shiftleftcount - 22;
          }
            }  
          
        
     if (buttonpress.out == 1){
          secondrow.d = firstrow.q;
          game_fsm.d = game_fsm.STARTROW2;
            
      }

        
         
     game_fsm.STARTROW2:
      
      edgerow1.in = slowclock2nd.value;
      shiftrightcount = 0;
      shiftingright.a = secondrow.q;
      shiftingright.b = b1;
      shiftingright.alufn_signal = b01; // shifts right first
      
      shiftleftcount = 0;
      shiftingleft.a = secondrow.q;
      shiftingleft.b = b1;
      shiftingleft.alufn_signal = b00; // shifts left after, then cycle repeats
      
      if (edgerow2.out == 1){
          shiftrightcount = shiftrightcount + 1;
          shiftleftcount = shiftleftcount + 1;
          
          if (shiftrightcount <= 11 | shiftrightcount >= 0){ //11 to be replaced with math involving 16 - size of block
            secondrow.d = shiftingright.shift;
            }
          
          if (shiftrightcount == 11){ //11 to be replaced with math involving 16 - size of block
            shiftrightcount = shiftrightcount - 22;
          }
            
          if (shiftleftcount >= 11 | shiftleftcount < 22 ){ //shiftleftcount could be > 11, not >=11. shiftrightcount < 22 to be replaced with  (16 - size of block) x 2
            secondrow.d = shiftingleft.shift;
          }
            
          if (shiftrightcount == 22){ //shiftrightcount < 22 to be replaced with  (16 - size of block) x 2
            shiftleftcount = shiftleftcount - 22;
          }
            }  
          
        
     if (buttonpress.out == 1){
          thirdrow.d = secondrow.q;
          game_fsm.d = game_fsm.STARTROW3;       
      }
      
        
        
        
      game_fsm.STARTROW3:
      
      edgerow3.in = slowclock3rd.value;
      shiftrightcount = 0;
      shiftingright.a = secondrow.q;
      shiftingright.b = b1;
      shiftingright.alufn_signal = b01; // shifts right first
      
      shiftleftcount = 0;
      shiftingleft.a = secondrow.q;
      shiftingleft.b = b1;
      shiftingleft.alufn_signal = b00; // shifts left after, then cycle repeats
      
      if (edgerow3.out == 1){
          shiftrightcount = shiftrightcount + 1;
          shiftleftcount = shiftleftcount + 1;
          
          if (shiftrightcount <= 11 | shiftrightcount >= 0){ //11 to be replaced with math involving 16 - size of block
            thirdrow.d = shiftingright.shift;
            }
          
          if (shiftrightcount == 11){ //11 to be replaced with math involving 16 - size of block
            shiftrightcount = shiftrightcount - 22;
          }
            
          if (shiftleftcount >= 11 | shiftleftcount < 22 ){ //shiftleftcount could be > 11, not >=11. shiftrightcount < 22 to be replaced with  (16 - size of block) x 2
            thirdrow.d = shiftingleft.shift;
          }
            
          if (shiftrightcount == 22){ //shiftrightcount < 22 to be replaced with  (16 - size of block) x 2
            shiftleftcount = shiftleftcount - 22;
          }
           }  
          
      if (buttonpress.out == 1){
          //thirdrow.d = secondrow.q;
          game_fsm.d = game_fsm.STARTROW1;
            
    }

  }
 }
     io_led[1] = firstrow.q[15:8];
     io_led[0] = firstrow.q[7:0];  
}
